---
# TODO: Upload ssh key and put machine in recovery with hetzner hcloud
# Change port and user to hetzner recovery's defaults
- name: Changing to default ssh parameters
  ansible.builtin.set_fact:
    edge_install_ansible_port: '{{ ansible_port }}'
    edge_install_ansible_user: '{{ ansible_user }}'
    ansible_port: 22
    ansible_user: root

# WARNING: THIS IS STILL UNTESTED, Everything else in this role is known to work but this task
# TODO: Check whether apt-get is idempotent and returns 0 if package is already installed
- name: Installing Python
  ansible.builtin.raw: 'apt-get -y -q update && apt-get -y -q install python3'
  register: edge_install_install_python_result
  changed_when: edge_install_install_python_result.rc == 0

# Gather facts to choose installation drive
- name: Gathering facts
  ansible.builtin.setup: {}

# Choose the first drive that isn't mounted
- name: Choosing installation drive
  ansible.builtin.set_fact:
    edge_install_installation_drive: '{{ item }}'
  loop: '{{ ansible_facts.devices.keys() | sort }}'
  # Set Fact runs only if the variable has not been defined and if the list of indices returned by index_of is empty
  when: >
    edge_install_installation_drive is undefined and
    (mounted_devices | ansible.utils.index_of('search', item, fail_on_missing=False, wantlist=True) | length) == 0
  vars:
    mounted_devices: '{{ ansible_facts.mounts | map(attribute="device") | unique }}'

- name: Fail if we couldn't find an installation drive
  ansible.builtin.fail:
    msg: 'Couldn''t find an installation drive among list: {{ ansible_facts.devices.keys() | list }}'
  when: edge_install_installation_drive is undefined

- name: Stop before installation
  ansible.builtin.pause:
    echo: False
    prompt: 'CoreOS is about to be installed {{ inventory_hostname }}''s remote device /dev/{{ edge_install_installation_drive }}. Use Ctrl+C to manage the flow or wait 10 seconds for the play to continue'
    seconds: 10

# Get Fedora CoreOS stable rootfs link from json (taken from the official download page)
- name: Setting Fedora CoreOS Download link
  delegate_to: localhost
  connection: local
  run_once: True
  ansible.builtin.set_fact:
    edge_install_download_url_object: '{{ lookup("url", "https://builds.coreos.fedoraproject.org/streams/stable.json", split_lines=False) | from_json | community.general.json_query(''architectures.x86_64.artifacts.metal.formats."raw.xz".disk'') }}'

# TODO: Check checksum?? It may be hard to do in the recovery environment
- name: Downloading and installing CoreOS
  ansible.builtin.shell:
    cmd: 'set -e && curl -sL "{{ edge_install_download_url_object.location }}" | xz -d >> /dev/{{ edge_install_installation_drive }} && sync'
  register: edge_install_curl_xz_result
  changed_when: edge_install_curl_xz_result.rc == 0

# After writing to the drive, we have to update the facts to get the new partition table
- name: Updating Facts
  ansible.builtin.setup: {}

# Get the first partition in the installation drive with label "boot"
- name: Finding Boot Partition
  ansible.builtin.set_fact:
    edge_install_boot_partition: '{{ item.path }}'
  loop: '{{ ansible_facts.devices[edge_install_installation_drive].partitions
    | dict2items(key_name="path", value_name="partition")
    | selectattr("partition.links.labels")
    | sort(attribute="path") }}'
  loop_control: 
    label: '{{ item.path }}'
  # Set Fact runs only if fact is undefined and if "boot" is found in one of the labels
  when: >
    edge_install_boot_partition is undefined and
    (item.partition.links.labels | map('lower') | select('search', 'boot') | length) != 0

- name: Fail if we couldn't find the boot partition
  ansible.builtin.fail:
    msg: 'Couldn''t find the boot partition among list: {{ ansible_facts.devices.keys() | list }}'
  when: edge_install_boot_partition is undefined

- block:
    # Mount boot partition
    - name: Mounting the boot partition
      ansible.posix.mount:
        boot: False
        src: '/dev/{{ edge_install_boot_partition }}'
        fstype: ext4
        path: /mnt/boot
        state: mounted

    # Locally generate Ignition config from Butane template
    - name: Generate Ignition config
      delegate_to: localhost
      connection: local
      block:
        # Create temporary file where to put the templated config
        - name: Creating temporary file to host templated config
          ansible.builtin.tempfile:
            suffix: '.bu'
          register: edge_install_butane_config
        - name: Templating Butane config
          ansible.builtin.template:
            src: ignition_file.bu.j2
            dest: '{{ edge_install_butane_config.path }}'
        # Transpile Butane config to get Ignition json
        - name: Transpiling Butane config
          containers.podman.podman_container:
            interactive: True
            detach: False
            rm: True
            image: quay.io/coreos/butane:release
            volume:
              - '{{ edge_install_butane_config.path }}:/config.bu'
            command: '--strict /config.bu'
            name: butane
          register: edge_install_ignition_config
      always:
        # Remove temporary file if created
        - name: Removing temporary files
          ansible.builtin.file:
            path: '{{ edge_install_butane_config.path }}'
            state: absent
          when: edge_install_butane_config is defined

    - name: Create ignition folder
      ansible.builtin.file:
        path: /mnt/boot/ignition
        state: directory
        mode: 0644

    # Write the ignition config in /boot/ignition/config.ign
    # (boot should be currently mounted to /mnt/boot)
    - name: Writing ignition config
      ansible.builtin.template:
        src: single_variable.j2
        dest: /mnt/boot/ignition/config.ign
        mode: 0644
      vars:
        content: '{{ edge_install_ignition_config.stdout }}'
  always:
    # Unmount the boot partition if mounted
    - name: Unmounting the boot partition
      ansible.posix.mount:
        boot: False
        path: /mnt/boot
        state: absent

# Reboot to disk (reboots deactivate hetzner's recovery environment)
# We ignore errors because sshd should be listening to another port
- name: Rebooting to disk
  ignore_errors: True
  ansible.builtin.reboot:
    msg: ''

# Turn everything back to normal
- name: Reapplying ssh config
  ansible.builtin.set_fact:
    ansible_port: '{{ edge_install_ansible_port }}'
    ansible_user: '{{ edge_install_ansible_user }}'

# Check if Reboot happened
- name: SSH Check
  ansible.builtin.wait_for_connection:
    timeout: 10
