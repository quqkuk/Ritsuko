---
# This should not run if the VM is not available on the default port, as the fact gathering fails
# thus, we can proceed with putting the VM in recovery mode without worrying that the OS will be re-installed even if not needed

#TODO: Refactor this file
- name: Put Server in Rescue Environment
  connection: local
  delegate_to: localhost
  block:
    - name: Upload ssh pubkey
      hetzner.hcloud.hcloud_ssh_key:
        api_token: '{{ hetzner_api_token }}'
        name: 'ansible-{{ inventory_hostname }}'
        fingerprint: '{{ lookup("ansible.builtin.pipe", ''ssh-keygen -l -E md5 -f ''+ansible_ssh_private_key_file+''.pub | sed ''''s/.*MD5:\([a-zA-Z0-9:]*\).*/\1/'''''') }}'
        public_key: '{{ lookup("ansible.builtin.file", ansible_ssh_private_key_file+".pub") }}'
        state: present
      register: hetzner_install_ssh_key
      failed_when: hetzner_install_ssh_key is failed and hetzner_install_ssh_key.msg != "SSH key name is already used"

    - name: Put server in recovery mode
      hetzner.hcloud.hcloud_server:
        api_token: '{{ hetzner_api_token }}'
        name: '{{ inventory_hostname }}'
        rescue_mode: linux64
        ssh_keys:
          - 'ansible-{{ inventory_hostname }}'
        state: restarted

- name: Waiting for server to come back up online after reboot
  ansible.builtin.wait_for_connection: {}

# TODO: Make this task idempotent
- name: Installing Python
  ansible.builtin.raw: 'apt-get -y -q update && apt-get -y -q install python3'
  register: hetzner_install_install_python_result
  changed_when: hetzner_install_install_python_result.rc == 0
  failed_when: hetzner_install_install_python_result.rc != 0

# Gather recovery mode facts to choose installation drive
- name: Gathering facts
  ansible.builtin.setup: {}

# Choose the first drive that isn't mounted
# TODO: Improve this algorithm as the rescue environment doesn't work like the test one
- name: Choosing installation drive
  ansible.builtin.set_fact:
    hetzner_install_installation_drive: '{{ item }}'
  loop: '{{ non_removable_devices }}'
  # Set Fact runs only if the variable has not been defined and if the list of indices returned by index_of is empty
  when: >
    hetzner_install_installation_drive is undefined and
    (mounted_partitions | ansible.utils.index_of('search', item, fail_on_missing=False, wantlist=True) | length) == 0
  vars:
    mounted_partitions: '{{ ansible_facts.mounts | map(attribute="device") | unique }}'
    non_removable_devices: '{{ ansible_facts.devices | dict2items | rejectattr(''value.removable'', "truthy", convert_bool=True) | map(attribute="key") | sort }}'
  failed_when: hetzner_install_installation_drive is undefined

- name: Stop before installation
  ansible.builtin.pause:
    echo: false
    prompt: 'MicroOS is about to be installed on {{ inventory_hostname }}''s remote device {{ (''/dev/'', hetzner_install_installation_drive) | path_join }}'
    seconds: 10

- name: Downloading and installing OS to disc
  block:
    - name: Sending installation script
      ansible.builtin.copy:
        src: install_ignition.sh
        dest: ./install_ignition.sh
        mode: 0544
    - name: Running installation script
      ansible.builtin.command: './install_ignition.sh {{ (''/dev/'', hetzner_install_installation_drive) | path_join }}'
      register: hetzner_install_script_result
      failed_when: hetzner_install_script_result.rc != 0
      changed_when: hetzner_install_script_result.rc == 0
  always:
    - name: Show command result
      ansible.builtin.debug:
        msg: '{{ hetzner_install_script_result is succeeded | ternary(hetzner_install_script_result.stdout_lines, hetzner_install_script_result.stderr_lines) }}'
      when: hetzner_install_script_result is defined
    # Remove script if sent
    - name: Removing installation script file
      ansible.builtin.file:
        path: ./install_ignition.sh
        state: absent

# Update facts with new partition
- name: Updating facts
  ansible.builtin.setup:
    gather_subset:
      - hardware

# The partition should have been created by install_ignition.sh
- name: Choose config partition
  ansible.builtin.set_fact:
    #TODO: Try to use labels
    hetzner_install_config_partition: '{{ partitions[-1] }}'
    hetzner_install_swap_partition: '{{ partitions[-2] }}'
    hetzner_install_data_partition: '{{ partitions[-3] }}'
  vars:
    partitions: '{{ ansible_facts.devices[hetzner_install_installation_drive].partitions.keys() | sort }}'

- name: Formatting the config partition
  community.general.filesystem:
    dev: '{{ (''/dev/'', hetzner_install_config_partition) | path_join }}'
    fstype: ext4
    opts: -L ignition
    state: present
    force: true

- name: Installing Combustion script
  block:
    # Mount config partition
    - name: Mounting the last partition
      ansible.posix.mount:
        src: '{{ (''/dev/'', hetzner_install_config_partition) | path_join }}'
        fstype: ext4
        path: /mnt/config
        state: mounted

    - name: Create combustion folder
      ansible.builtin.file:
        path: /mnt/config/combustion
        state: directory
        mode: 0755

    - name: Add script file
      vars:
        config_partition_details: '{{ ansible_facts.devices[hetzner_install_installation_drive].partitions[hetzner_install_config_partition] }}'
        swap_partition_details: '{{ ansible_facts.devices[hetzner_install_installation_drive].partitions[hetzner_install_swap_partition] }}'
        data_partition_details: '{{ ansible_facts.devices[hetzner_install_installation_drive].partitions[hetzner_install_data_partition] }}'
      ansible.builtin.template:
        src: combustion_script.j2
        dest: /mnt/config/combustion/script
        mode: 0744

    - name: Copy selinux policy
      ansible.builtin.copy:
        src: snapperd_snapshot_var.pp
        dest: /mnt/config/combustion/snapperd_snapshot_var.pp
        mode: 0744
  always:
    # Unmount the config partition if mounted
    - name: Unmounting the last partition
      ansible.posix.mount:
        path: /mnt/config
        state: absent

# Reboot to disk (reboots deactivate hetzner's recovery environment)
# We have a very short timeout and ignore errors because sshd may be listening to another port
- name: Rebooting to disk
  ansible.builtin.reboot:
    msg: Rebooting to disk
    connect_timeout: 1
    reboot_timeout: 1
  ignore_errors: true
  #TODO: Maybe the registered value can let us discern whether we've failed to reboot or not
  # we don't care about the machine coming up because it is probably going to be on a different port

- name: Enable Hetzner Backups
  connection: local
  delegate_to: localhost
  hetzner.hcloud.hcloud_server:
    api_token: '{{ hetzner_api_token }}'
    name: '{{ inventory_hostname }}'
    backups: true
